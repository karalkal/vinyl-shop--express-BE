# API for mock vinyl shop

### Description

  This application is intended to builds an API for mock vinyl shop.  

  Some endpoints are accessible to all users (e.g. when browsing the inventory).
  
  Users can register and login to have access to the ordering and other functionalities (e.g. viewing other registered users' profiles) - userAuthentication middleware enables this functionality.  

  Admin permissions can be generated by accessing the DB directly only in order to avoid regular users assigning themselves privileges they aren't supposed to have. Admin users can create new bands/labels/styles/users/inventory items and so on, edit and delete existing ones and basically manipulate the DB.  

  Each vinyl must be linked to an existing label and band (meaning these need to be created in advance).  
  
  The ordering process works as follow:  
  An INSERT query INTO a `album_purchase` intermediary table is generated since the link between album and user is many-2-many, e.g. one user can order multiple albums, one album could be ordered by multiple users. Each `album_purchase`entry will have an unique ID (which we are not really interested in) and a **purchase_id** and **album_id** identifiers. When the user places an order we insert into purchases an entry related to the the given cart_no - hence we know which user has ordered what albums in an order with this cart_no. To clarify user 1 creates order 1 with albums A and B (will be a number in real world). In `album_purchase` we will have two entries:

  ```sql
  id      purchase_id       album_id
  ----------------------------------
  1       1                 A
  2       1                 B

  ```

---

### Non-express files included in repo

*[DB structure (ERD) and sql scripts](https://github.com/karalkal/vinyl-shop--express-BE/blob/main/extras-ERD-Postman/erd_new.pdf)*

---

### API deployed at

*<https://vinyl-shop.onrender.com/api/v1>*

### Example link

*<https://vinyl-shop.onrender.com/api/v1/bands>*  

---

### Swagger documentation at

*<https://vinyl-shop.onrender.com/>*  
### YAML for OpnAPI created using  [APIMatic](https://www.apimatic.io/)  

*logging in as *<k*******44@gmail.com>**

1. import json operated by postman
2. go through settings, e.g. remove authentication from unprotected routes
3. export as yaml v3
4. edit file in swagger editor
5. install yamljs and swagger-ui-express
6. require both, load .yaml document, serve it at required url

---

### PostgreSQL DB hosted at

*elephantsql.com*

### To log in to DB use email address

*<k*******44@gmail.com>*  

---

### To install app locally use `npm i`

## *Some notes on the implementation code*

- Routes contain a parent router which integrates all the child routers, such as log-in, album, order, user etc.
- `authRouter.post('/register', register)`and `authRouter.post('/login', login)` and some GET routes will not require verification of user credentials, for obvious reasons.
- Admin privileges to an user can be granted from the DB only. In other words upon registration if is_admin: true is included in the request body this will not be included in the query sent to the DB. Same restriction is applied when editing users, current state will be copied.
- Regular users can see an overview of all other users at `/users` - names and location only, but cannot see individual user info `users/:id`
- Each of the other child routes a token will be required. These will be created using the `jsonwebtoken` library upon login/registration. The FE will send these as Bearer token included in the header. will first check if the user is authenticated or with admin privileges (depending on the route) using the userAuthentication and/or adminAuthorization middlewares. These check the token sent in the header of the relevant request - `req.headers.authorization`
- Interaction with the DB is established using the [**pg** package](https://www.npmjs.com/package/pg). It is  a non-blocking PostgreSQL client for Node.js. A Pool object is created with the connection parameters in db/connect.js, it is exported, then we can send queries using Postgres syntax like:

```
pool.query('SELECT id, f_name, l_name, city, country FROM db_user ORDER BY id ASC', (error, results) => {
    ........
}
```

- Security middleware included for the production version

  - helmet
  - cors
  - xss-clean
  - express-rate-limit

- Google login:  
The tokens returned from google's api contain different user data than the one this app needs. To ensure consistency with our existing db_user table we are constructing a new object from it to include user's data (email and names). Later we add the user_id from our db, not the google one, create jwt and send the whole thing to FE. The insert query when creating user runs asynchronously. As a result if the data is sent outside of the if... else... block the app will send data to the FE without the user_id, then errors will appear if they try to place an order, hence the repetition of code for existing and newly created users.
- Admin privileges:  
The BE will return a data object to the FE which will contain user data, such as names, email and **is_admin** and a **js token**. The `is_admin` property will allow the user to access protected routes but only after our BE has checked the token. In other words, the `is_admin` property is only preliminary check at the FE - if `false` the user will not be able to access the protected routes at all. But if anyone changes it manually to `true` and accesses the protected routes, they will still have to pass our adminAuthorization to access protected data.

---

### *Possible issues (could be resolved at FE level)*

- (fixed) order could be created with non-existing cart_no, will be empty.
- (fixed) can also post order to an user who is NOT related to cart, e.g. user1 adds to cart_no 1 but then post order with this cart_no to user2. User 2 will then have empty array of ordered items but price will still be updated.
